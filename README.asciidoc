// vim:set ft=asciidoc:
SCC — Simple CC  
===============

_SCC_ is _+++C++ +++_ snippets evaluator , with some _AWK_ features.


Status
------

Current alpha version is v0.2 (use this git tag). Only GCC-4.7 (pre release) or later is currently supported.  
Version v0.2 is about x100 times faster than v0.1 and about x2 times faster than GAWK/MAWK. 
Boost is not used in v0.2.  Regex in RS/FS are currently not supported (but were in v0.1) 

If you need to use it with older GCC (4.1 was supported) - use v0.1.

Install
-------

-----------------------------------------
git clone http://github.com/lvv/scc
echo PATH+=":$PWD/scc" >> ~/.profile
. ~/.profile
---------------------------------------

REPL
----

SCC can be used as simple REPL for +++ C++ +++.  Expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If last (or only) statement in snippet is not terminated with semicolon it is sent to `std::cout`.
If snippet have _Bash_ special characters,  it must be in single or double
quotes. If expression starts with minus, end-of-options indicator "--" must be used:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc -- -42
-42

scc 'double x=0.5;  sin(x)'						
0.479426

echo "ABC"  |  scc 'char c;  while (cin.get(c))  cout << (char)tolower(c);'
abc
----------------------------------------------------------------------------


To squeeze C++ verbosity for SCC's one-liners, several things were done. 

Shortcuts (typedefs and macros) were defined:

------------------------------------------------------
str	-->   std::string  
vint	-->   std::vector<int>  
O	-->   while(read_line())      
------------------------------------------------------

Variables `i`,`j`,`k`,`n` are
pre-declared as `long`; variables `x`,`y`,`z` are pre-declared as `double`; 
and `s` and `w` - pre-declared as `std::string`.  Numeric types initialized to 0.
So, in last example we could've skipped definition `char c;`.
You don't need to remember these, you can re-declare/re-define these as you want. 

Also C++ printing was replaced with so called
http://volnitsky.com/project/scc/#_simplified_printing[bar-print]
and any stl container can be simply sent to `std::cout`.
In comments are  equivalent statement:

---------------------------------------------------------------
_  x;                           //  cout << x;
__ x;                           //  cout << x << endl;
__ x << y;                      //  cout << x << endl;
__ x, y;                        //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

More examples.  Square an array.  +++C++11 +++ is on by default:

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(auto v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Calculate words frequencies from stdin:

----------------------------------------------------------------------------
echo aa bb aa | scc 'str w;  map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------

Native AWK
----------

After initial use as simple REPL evaluator, I realised that SCC can be useful
tool for stream processing - something like native AWK.  So it was bolted on to SCC.
Syntax is not exactly AWK's,  it is still +++C++ +++,  but I've tried to make it similar.

AWK's program have following layout:

`awk 'BEGIN{begin-expr};  /re1/{expr1};  /re2/{expr2};  END{end-expr}'`

SCC have two alternatives. First is simple while-loop:

`scc 'begin-expr;  O { expr1; expr2;};   end-expr;'`

Shortcut `O` expands to `while(read_line())`.  
Function `read_line()`, reads input line and splits it into fields.

Second is `-n` and `-p` (equivalent to PERL's)  options:

`scc -n 'expr1; expr2;'`

Options `-p`, after splitting and evaluating snippet also prints `$0`.

SCC does not have dedicated place for regexes, so we use vanilla if-statement.

With luck, GCC supports (as extension)  use of `$` in identifiers, so AWK's dollar 
variables (`$0`, `$1`, `$NF`) are valid in SCC.

In SCC, `$` variables are special string type `fld`, it is similar to `std::string` but it can be
used in arithmetic expressions - implicitly converted to a numeric type. And it
can be assigned a numeric value. That is `fld` behave like AWK's vars.
Numeric types are any of `int`, `float`, etc.


Examples.

Sum-up _DF(1)_ used-disk-space column. 
In AWK:

----------------------------------------------------------------------------
df | awk '{n+=$3};  END{print n}'
31399199
----------------------------------------------------------------------------

If your `df` output sizes in human readable sizes, you need to replace `df` with `command df`.

Same in SCC:

----------------------------------------------------------------------------
df | scc 'O n+=$3;  n' 
31399199
----------------------------------------------------------------------------

We can also replace column number with symbolic name (from df output header):

----------------------------------------------------------------------------
df | scc -H 'O n+=$("Used");  n' 
31399199
----------------------------------------------------------------------------

Prepend line number to every line.

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |  scc -p '$.push_front(NR);'
1 aaa
2 bbb
----------------------------------------------------------------------------

When input line split into fiels, they are kept in `std::deque<fld> F`  (`$` - is
alias to `F`).  So to prepend  new field with `NR`, we used `std::deque`  member function
`push_front`.  Another way for doing the same:

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
1 aaa
2 bbb
----------------------------------------------------------------------------

Note no-trailing-semicolon.

Make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator), `-i` - set `FS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -i: -o, -p
1,2,3
----------------------------------------------------------------------------


Replace `"-"` or  `"none"` with `"n/a"` in 2nd column using `std::regex`. 

----------------------------------------------------------------------------
echo -e '1 -\n2 none\n3 abc'  |  scc -p 'if ($2 == "(none|-)"_R)  $2="n/a";'
1 n/a
3 n/a
4 abc


// awk
echo -e '1 -\n2 none\n3 abc'  |  awk '{if ($2 ~ /^(none|-)$/)  $2="n/a"; print $0}'
1 n/a
3 n/a
4 abc
----------------------------------------------------------------------------

C-string with `_R` suffix are `std::regex` literal.  The `operator==` calls `std::regex_match()`.
Unfortunately GCC's LIBSTDC++ not yet have working `std::regex_replace` and `std::regex_search` and we have to use if.

See full docs at http://volnitsky.com/project/scc[]
