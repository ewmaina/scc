// vim:set ft=asciidoc:
SCC — Simple C++  
===============

_SCC_ is _+++C++ +++_ snippets evaluator , with some _AWK_ features. +

* Repo: httpx://github.com/lvv/scc[GitHub],  httpx://bitbucket.org/lvv/scc[BitBucket] +
* License:  httpx://www.gnu.org/licenses/gpl-3.0.html[GPL3]


Status
------

Current alpha version is v0.2 (use this git tag). Only GCC-4.7 (pre release) or later is currently supported.  
Version v0.2 is about x100 times faster than v0.1 and several times faster than GAWK/MAWK. 
Boost is not used in v0.2.  Regex in RS/FS are currently not supported (but were in v0.1) 

If you need to use it with older GCC (4.1 was supported) - use v0.1.

Install
-------

-----------------------------------------
git clone http://github.com/lvv/scc
echo PATH+=":$PWD/scc" >> ~/.profile
. ~/.profile
---------------------------------------


Overview
--------

C++ REPL
~~~~~~~~~

SCC can be used as simple REPL for +++ C++ +++.  Expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If expresion is not terminated with semicolon, it is sent to `std::cout`.
Same is true for last expression if we have multi-statment snippet.
If snippet have bash special characters,  it must be in single or double
quotes. If expression starts with minus, end-of-options indicator "--" must be used:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc -- -42
-42

scc 'double x=0.5;  sin(x)'						
0.479426

echo "ABC"  |  scc 'char c;  while (cin.get(c))  cout << (char)tolower(c);'
abc
----------------------------------------------------------------------------


To squeeze C++ verbosity for SCC's one-liners, several things were done. 

Snippet is evaluated in environ where all STL includes are included and almost
all STL objects are imported into default namespace with `using std::...;`

Some shortcuts (typedefs and macros) were defined:

------------------------------------------------------
str	-->   std::string  
vint	-->   std::vector<int>  
WRL	-->   while(read_line())      
------------------------------------------------------


Several variables were pre-declared:

* `i`, `j`, `k`, `n`, `m` -- `long`, initialized to 0
* `x`, `y`, `z` --  `double`, initialized to 0
* `s`, `w` -- `std::string`
* `c` -- char

You don't need to remember these, you can
re-define these to what ever you want. 
So, in last example we could've skipped
definition `char c;`. 

Also C++ printing was replaced with so called
http://volnitsky.com/project/scc/#_simplified_printing[bar-print]
and any STL container can be simply sent to `std::cout`.
Below are bar-print statements with equivalent code in comments:

---------------------------------------------------------------
_  x;                           //  cout << x;
__ x;                           //  cout << x << endl;
__ x << y;                      //  cout << x << endl;
__ x, y;                        //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

More examples.  Square an array.  +++C++11 +++ is on by default:

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(auto v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Calculate words frequencies from stdin.

----------------------------------------------------------------------------
echo aa bb aa | scc 'str w; map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------


Native AWK
~~~~~~~~~~

After initial use as simple REPL evaluator, I realised that SCC can be useful
tool for stream processing - something like native AWK.  So it was bolted on to SCC.
Syntax is not exactly AWK's,  it is still +++C++ +++,  but I've tried to make it similar.

AWK's program have following elements (simplified):

----------------------------------------------------------------------------
awk 'BEGIN{begin-expr};  per-record-expr;  END{end-expr}'
----------------------------------------------------------------------------

SCC is deferent, it have two alternatives for above. First is simple while-loop:

----------------------------------------------------------------------------
scc 'begin-expr;  WRL  per-record-expr;   end-expr;'
----------------------------------------------------------------------------

Shortcut `WRL` expands to `while(read_line())`.  
Function `read_line()`, reads input line and splits it into fields.

Second alternative is to use options `-n` and `-p`.
With `-n`, record is read, split into fields and snippet is eveluated for every
record.  With `-p`, additionally all fields are printed after snippet was
evaluated.  These are equivalent to PERL's and 
are convenient when we do not have `begin-expr` and `end-expr`.

----------------------------------------------------------------------------
scc -n 'per-record-expr;'
----------------------------------------------------------------------------

Fortunately,  GCC allows use of `$` in identifiers, so AWK's dollar 
variables (`$0`, `$1`, `$NF`) are valid in SCC.

In SCC, `$` variables are of special string type `fld`, it is similar to `std::string` but it can be
used in arithmetic expressions - they will be implicitly converted to corresponding numeric type. And it
can be assigned a numeric value. That is `fld` behave like AWK's vars.
Numeric types are any of `int`, `float`, etc.


More examples.  Sum-up `DF(1)` used-disk-space column.  In AWK and SCC:

----------------------------------------------------------------------------
df | awk '{n+=$3};  END{print n}'
31399199

df | scc 'WRL n+=$3;  n' 
31399199
----------------------------------------------------------------------------

We can also replace column number with symbolic name (from `df` output header):

----------------------------------------------------------------------------
df | scc -H 'WRL n+=$("Used");  n' 
31399199
----------------------------------------------------------------------------

Prepend line number to every line.

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
1 aaa
2 bbb
----------------------------------------------------------------------------

For every line: first `NR` is printed (notice that there is no semicolon), then $0.

Now lets make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator), `-F` - set `FS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -F: -o, -p
1,2,3
----------------------------------------------------------------------------

Or equivalent:

----------------------------------------------------------------------------
echo 1:2:3 | FS=: OFS=, scc -p
1,2,3
----------------------------------------------------------------------------


Replace `"-"` or  `"none"` with `"n/a"` in 2nd column using `std::regex`.  In AWK and SCC:

---------------------------------------------------------------------------
echo -e '1 -\n2 none\n3 abc'  |  awk '{gsub(/^(none|-)$/,"n/a",$2);  print $0}'
1 n/a
3 n/a
4 abc

echo -e '1 -\n2 none\n3 abc'  |  scc -p 'if ($2 == "(none|-)"_R)  $2="n/a";'
1 n/a
3 n/a
4 abc
----------------------------------------------------------------------------



C-string with `_R` suffix are `std::regex` literal.  The `operator==` calls `std::regex_match()`.
Unfortunately GCC's LIBSTDC++ not yet have working `std::regex_replace` and `std::regex_search` and we have to use `if`.

See full docs at http://volnitsky.com/project/scc[]
