// vim:set ft=asciidoc:
SCC — Simple CC  
===============

_SCC_ is _+++C++ +++_ snippets evaluator (REPL without L), with some _AWK_ features.  Implemented as GCC wrapper.


Status
-------
For all examples to work use commit tagged as v0.1;  gcc-4.6 or newer and _Boost_ . This page describes v0.1. 
If used as simple REPL, older gcc (tested with gcc-4.4) will work too and Boost is not needed. 

Tip of master branch (do not use) is about x100 faster for AWK ops, but only  gcc-4.7 is supported  and Boost is not used.

Examples
--------

C++ expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If snippet have _Bash_ special characters,  it must be in single or double
quotes. If expresion starts with minus, end-of-options indicator "--" must be used:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc 'sin(0.5)'						
0.479426

scc -- -1-INT_MIN
2147483647

----------------------------------------------------------------------------

A multi-statement with explicit printing.
Note trailing semicolon - meaning do not send last expression +
to `std::cout`

----------------------------------------------------------------------------
scc 'double x=0.5;  cout << sin(x) << endl;'			
0.479426
----------------------------------------------------------------------------

_SCC_ includes `simple.h` which has a lot of shortcuts (à la _Google CodeJam_).
Same as previous example, but with _SCC's_ shortcuts (
http://volnitsky.com/project/scc/#_simplified_printing[bar-print] and pre-declared vars)

----------------------------------------------------------------------------
scc 'x=0.5;  __ sin(x);'	
0.479426
----------------------------------------------------------------------------

All _STL_ containers can be sent to `std::cout`.   Typedef `vint` is `std::vector<int>`: 

---------------------------------------------------------------------------
scc 'vint  v{1,2,3};  v'
{1, 2, 3}

scc 'tuple<const char*,int>  v{"aaa",2};  v'
⟨aaa, 2⟩

scc 'tuple<const char*,int,tuple<int,float>>  v{"aaa",2,make_tuple(3,4.5f)};  v'
⟨aaa, 2, ⟨3, 4.5⟩⟩

scc 'map<int,int>  v{{1,1},{2,2}};  v'
{⟨1,1⟩, ⟨2,2⟩}

scc 'set<int>  v{2,2};  v'
{2}

scc 'vector<vint>  v{{1,1}, {2,2}};  v'
{{1, 1}, {2, 2}}

scc 'int  v[3]{1,2,3};  v'
{1, 2, 3}

scc 'vector<map<str,int>>  v{{{"aa",1}, {"bb",2}}};  v' 
{{⟨aa,1⟩, ⟨bb,2⟩}}

---------------------------------------------------------------------------

Square an array.  +++C++ 11 +++ is on by default.  gcc-4.6.0 or newer is needed for this example

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(auto v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Words frequencies (typedef `str` is `std::string`):

----------------------------------------------------------------------------
echo aa bb aa | scc 'str w;  map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------


Sum-up _DF(1)_ used-disk-space column:

----------------------------------------------------------------------------
df  |  scc 'WRL n+=F2;  n'
31399199
----------------------------------------------------------------------------


***************************************************************************
Explanation:
Shortcut `WRL` expands to `while(read_line())`.  
Function `read_line()`, reads input line, splits it into fields. One input line is an array of fields `F`.
To access 3nd field use `F(2)` or `F2`.
Class `F` derived from `std::deque<field>`. 
Type `field`  (derived from `std::string`) can be directly converted to/from numeric types.
The `F` member function  `operator()`  is safe version of `operator[]`.

Variables `i`,`j`,`k`,`n` are
pre-declared as `long`; variables `x`,`y`,`z` are pre-declared as `double`; 
and `s` - pre-declared as `std::string`.  Numeric types initialized to 0.
You don't need to remember these, you can re-declare/re-define these freely. 
****************************************************************************


Prepend line number to every line.
Option `-p` is similar to _PERL's_. It does `while(read_line())`,  evaluates snippet and prints `F`.
Global variable `NR` - number of record: 

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |  scc -p 'F.push_front(NR);'
0 aaa
1 bbb
----------------------------------------------------------------------------

Another way for doing the same:

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
0 aaa
1 bbb
----------------------------------------------------------------------------

Make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator), `-i` - set `FS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -i: -o, -p
1,2,3
----------------------------------------------------------------------------

Read _CSV_ file with quoted fields (spaces, commas and escaped quotes in field are allowed):
Option `-I`, like `-i`,  also sets `FS`, but now you can use regex; `CSV` - predefined regex constant.
How to make your own regexes  for `FS`  - look in `scc.h`

----------------------------------------------------------------------------
echo '"aa",  "bb\"-, bb",  "cc"'   |   scc -I CSV  -o '"\n"' -p
aa
bb\"-, bb
cc
----------------------------------------------------------------------------

Replace `"-"`, `"none"` and empty fields with `"n/a"` in 2nd column using `boost::regex`. 
Boost use in _SCC_ is optional, it will be used if `/usr/include/boost` exist.
`RR` is shortcut for `boost::regex_replace`;  shortcut `R` is `boost::regex`

----------------------------------------------------------------------------
echo \
'1 -
2
3 none
4 abc'  |   scc -p 'F1=RR(F1,R("^(none|-)?$"),"n/a");'
1 n/a
2 n/a
3 n/a
4 abc
----------------------------------------------------------------------------


/////////////////////////////////
 echo -e '11 222222222222\n1111111111 22' |scc -n 'FMT("%s %|20t| %s") %F[0] %F[1]'
///////////////////////////////////


See full docs at http://volnitsky.com/project/scc[]
