// vim:set ft=asciidoc:
SCC — Simple CC  
===============

_SCC_ is _+++C++ +++_ snippets evaluator , with some _AWK_ features.


Status
-------

Current alpha version is v0.2 (use this git tag). Only GCC-4.7 (pre release) is currently supported.  
Version v0.2 is about x100 times faster than v0.1 and about x2 times faster than GAWK/MAWK. 
Boost is not used in v0.2.  Regex in RS/FS are currently not supported (but were in v0.1) 

If you need to use it with older GCC (4.1 was supported) use v0.1.


REPL
----

SCC can be used as simple REPL for +++ C++ +++.  Expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If snippet have _Bash_ special characters,  it must be in single or double
quotes. If expresion starts with minus, end-of-options indicator "--" must be used:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc -- -42
-42

scc 'double x=0.5;  sin(x)'						
0.479426

----------------------------------------------------------------------------

If last (or only) statment is not terminated with simicolon it is sent to `std::cout`.

To squise C++ verbosity, shortcuts (typedefs and macros) were defined:

------------------------------------------------------
str   -->   std::string  
vint  -->   std::vector<int>  
WRL   -->   while(read_line())      
------------------------------------------------------

Variables `i`,`j`,`k`,`n` are
pre-declared as `long`; variables `x`,`y`,`z` are pre-declared as `double`; 
and `s` - pre-declared as `std::string`.  Numeric types initialized to 0.
You don't need to remember these, you can re-declare/re-define these freely. 


C++ printing was replaced with so called
http://volnitsky.com/project/scc/#_simplified_printing[bar-print]
and any stl container can be simply sent to `std::cout`.
In comments are  equivalent to statement:

---------------------------------------------------------------
_  x;                           //  cout << x;
__ x;                           //  cout << x << endl;
__ x << y;                      //  cout << x << endl;
__ x, y;                        //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

More complex examples.  Square an array.  +++C++11 +++ is on by default:

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(auto v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Calculate words  frequencies from stdin:

----------------------------------------------------------------------------
echo aa bb aa | scc 'str w;  map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------

Native AWK
----------

After inital use as simple REPL calculator, I realised that SCC can be usefull
tool for stream processing - something like native AWK.  So it was bolted on to SCC.
Sintax is not exactly AWK's but I've tried to make it similar.


AWK's statements have following layout:

`awk 'BEGIN{begin-expr};  /re1/{expr1};  /re2/{expr2};  END{end-expr}'`

SCC have two equvalent alternative for above. First is simple while-loop:

`scc 'begin-expr;  WRL { expr1; expr2;};   end-expr;'`

Shortcut `WRL` expands to `while(read_line())`.  
Function `read_line()`, reads input line, splits it into fields.

Second is `-n` and `-p` (equivalent to PERL's)  options:

`scc 'expr1; expr2'`

SCC does not dedicated place for regexes, but we can use vanilla if-statment.

But luck, GCC supports (as extention)  use of `$` in identifiers, so all AWK's
variables (`$0`, `$1`, `$NF`) are valid in SCC.

`$` variables have special type, which is simplar to `std::string` but which can
be used in arithmetic expresion and be assigned/retrived a numeric value (like
in AWK).


Examples.

Sum-up _DF(1)_ used-disk-space column:

----------------------------------------------------------------------------
df | scc 'WRL n+=$3;  n' 
31399199

// same as:
df | awk '{n+=$3};  END{print n}'
31399199
----------------------------------------------------------------------------

Prepend line number to every line.

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |  scc -p 'F.push_front(NR);'
1 aaa
2 bbb
----------------------------------------------------------------------------

Fields  are kept in `std::vector<fld> F`, so to prepend line number we `push_front`-ed  `NR`.
Another way for doing the same:

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
1 aaa
2 bbb
----------------------------------------------------------------------------

Make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator), `-i` - set `FS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -i: -o, -p
1,2,3
----------------------------------------------------------------------------








Replace `"-"`, `"none"` and empty fields with `"n/a"` in 2nd column using `boost::regex`. 
Boost use in _SCC_ is optional, it will be used if `/usr/include/boost` exist.
`RR` is shortcut for `boost::regex_replace`;  shortcut `R` is `boost::regex`

----------------------------------------------------------------------------
echo \
'1 -
2
3 none
4 abc'  |   scc -p 'F1=RR(F1,R("^(none|-)?$"),"n/a");'
1 n/a
2 n/a
3 n/a
4 abc
----------------------------------------------------------------------------


/////////////////////////////////
 echo -e '11 222222222222\n1111111111 22' |scc -n 'FMT("%s %|20t| %s") %F[0] %F[1]'
///////////////////////////////////


See full docs at http://volnitsky.com/project/scc[]
