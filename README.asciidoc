// vim:set ft=asciidoc:
SCC — Simple CC  
===============

// (aka Snippet C++ Compiler)

A _Bash_ wrapper for _GCC_ which serve as _+++C++ +++_ snippet evaluator or as something
similar to _AWK_ with _+++C++ +++_ syntax.  You need _>=GCC-4.6.0_ and _BOOST_ for all
features to work. Examples:

_+++C++ +++_ expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If snippet have Bash special characters,  it must be in single or double quotes:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc 'sin(0.5)'						
0.479426
----------------------------------------------------------------------------

A multi-statement with explicit printing.
Note trailing semicolon - meaning do not print last statement-expression:

----------------------------------------------------------------------------
scc 'float x=0.5;  cout << x << " " << sin(x) << endl;'			
0.5 0.479426
----------------------------------------------------------------------------

_SCC_ includes `simple.h` which has a lot of shortcuts (à la _Google CodeJam_).  You don't
have to use these, plain _+++C++ +++_ will work too. 

Same as previous example, but with _SCC's_ shortcut for `std::cout` - bar-print. Used `operator^` prints an object with prepended space.
See http://volnitsky.com/project/scc/#_simplified_printing[bar-print description]. 

----------------------------------------------------------------------------
scc 'float x=0.5;  __ x ^ sin(x);'	
0.5 0.479426
----------------------------------------------------------------------------

Square an array.  +++C++0x+++ is on by default.  Current (>=4.6.0) _GCC_ is needed for this example. 
_STL_ containers are printable. Typedef `vint` is `std::vector<int>`: 

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(int& v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Word frequencies (typedef `str` is `std::string`):

----------------------------------------------------------------------------
echo aa bb aa | scc 'str w;  map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------

Sum-up _DF(1)_ used-disk-space column.
Shortcut `WRL` is  `while(read_line())`.  
Class `F` derived from `deque<field>`.  Every input line is split into `F`.
Type `field` can be directly converted to/from numeric types.
The `F` member function  `operator()`  is safe version of `operator[]`.

----------------------------------------------------------------------------
df  |  scc 'int n=0;  WRL n+=F(2);  n'
31399199
----------------------------------------------------------------------------

In above example,  `int n=0;` was actually optional.  Variables `i`,`j`,`k`,`n` are
pre-declared as `int`; variables `x`,`y`,`z` are pre-declared as `double`; 
and `s` - pre-declared as `std::string`.  Numeric types initialized to 0.
You can re-declare/re-define these if needed.

Prepend line number to every line.
Option `-p` is similar to _PERL's_;  Global variable `NR` - number of record; 

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |  scc -p 'F.push_front(NR);'
0 aaa
1 bbb
----------------------------------------------------------------------------

Another way for doing the same. Note no trailing semicolon:

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
0 aaa
1 bbb
----------------------------------------------------------------------------

Make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator)., `-i` - set `IFS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -i: -o, -p
1,2,3
----------------------------------------------------------------------------

Read _CSV_ file with quoted fields (spaces, commas and escaped quotes in field are allowed):
Option `-I` sets regex `IFS` (input field separator); `CSV` - predefined regex constant.
How to make your own regexes  for `IFS`  - look in `scc.h`

----------------------------------------------------------------------------
echo '"aa",  "bb\"-, bb",  "cc"'   |   scc -I CSV  -o '"\n"' -p
aa
bb\"-, bb
cc
----------------------------------------------------------------------------

Replace `"-"`, `"none"` and empty fields with `"n/a"` in 2nd column using `boost::regex`. 
Boost use in _SCC_ is optional, it will be used if `/usr/include/boost` exist.
`RR` is shortcut for `boost::regex_replace`;  `R` - `boost::regex`

----------------------------------------------------------------------------
echo \
'1 -
2
3 none
4 abc'  |   scc -p 'F(1)=RR(F(1),R("^(none|-)?$"),"n/a");'
1 n/a
2 n/a
3 n/a
4 abc
----------------------------------------------------------------------------


/////////////////////////////////
 echo -e '11 222222222222\n1111111111 22' |scc -n 'FMT("%s %|20t| %s") %F[0] %F[1]'
///////////////////////////////////


See full docs at http://volnitsky.com/project/scc[]
