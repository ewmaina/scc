// vim:set ft=asciidoc:
SCC — Simple CC  
===============

// (aka Snippet C++ Compiler)

A _Bash_ wrapper for _GCC_ which serves as _+++C++ +++_ snippet evaluator or as something
similar to _AWK_ with _+++C++ +++_ syntax.  You need _>=GCC-4.6.0_ and _BOOST_ for all
features to work. 

_+++C++ +++_ expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If snippet have _Bash_ special characters,  it must be in single or double
quotes. If expresion starts with minus, end-of-options indicator "--" must be used:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc 'sin(0.5)'						
0.479426

scc -- -1-INT_MIN
2147483647

----------------------------------------------------------------------------

A multi-statement with explicit printing.
Note trailing semicolon - meaning do not send last expression +
to `std::cout`

----------------------------------------------------------------------------
scc 'double x=0.5;  cout << sin(x) << endl;'			
0.479426
----------------------------------------------------------------------------

_SCC_ includes `simple.h` which has a lot of shortcuts (à la _Google CodeJam_).
Same as previous example, but with _SCC's_ shortcut
for `std::cout` - http://volnitsky.com/project/scc/#_simplified_printing[bar-print]. 

----------------------------------------------------------------------------
scc 'double x=0.5;  __ sin(x);'	
0.479426
----------------------------------------------------------------------------

Square an array.  +++C++11+++ is on by default.  Current (>=4.6.0) _GCC_ is
needed for this example.  Include `simple.h` makes from _STL_ containers an
object objects which you can print. Typedef `vint` is `std::vector<int>`: 

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(auto v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Words frequencies (typedef `str` is `std::string`):

----------------------------------------------------------------------------
echo aa bb aa | scc 'str w;  map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------

Sum-up _DF(1)_ used-disk-space column:

----------------------------------------------------------------------------
df  |  scc 'WRL n+=F2;  n'
31399199
----------------------------------------------------------------------------


__________________________________________________________________
Explanation:
Shortcut `WRL` expands to `while(read_line())`.  
Function `read_line()`, reads input line, splits it into fields. One input line is an array of fields `F`.
To access 3nd field use `F(2)` or `F2`.
Class `F` derived from `std::deque<field>`. 
Type `field`  (derived from `std::string`) can be directly converted to/from numeric types.
The `F` member function  `operator()`  is safe version of `operator[]`.

Variables `i`,`j`,`k`,`n` are
pre-declared as `long`; variables `x`,`y`,`z` are pre-declared as `double`; 
and `s` - pre-declared as `std::string`.  Numeric types initialized to 0.
You don't need to remember these, you can re-declare/re-define these freely. 
__________________________________________________________________


Prepend line number to every line.
Option `-p` is similar to _PERL's_. It does `while(read_line())`,  evaluates snippet and prints `F`.
Global variable `NR` - number of record: 

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |  scc -p 'F.push_front(NR);'
0 aaa
1 bbb
----------------------------------------------------------------------------

Another way for doing the same:

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
0 aaa
1 bbb
----------------------------------------------------------------------------

Make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator), `-i` - set `IFS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -i: -o, -p
1,2,3
----------------------------------------------------------------------------

Read _CSV_ file with quoted fields (spaces, commas and escaped quotes in field are allowed):
Option `-I`, like `-i`,  also sets `IFS`, but now you can use regex; `CSV` - predefined regex constant.
How to make your own regexes  for `IFS`  - look in `scc.h`

----------------------------------------------------------------------------
echo '"aa",  "bb\"-, bb",  "cc"'   |   scc -I CSV  -o '"\n"' -p
aa
bb\"-, bb
cc
----------------------------------------------------------------------------

Replace `"-"`, `"none"` and empty fields with `"n/a"` in 2nd column using `boost::regex`. 
Boost use in _SCC_ is optional, it will be used if `/usr/include/boost` exist.
`RR` is shortcut for `boost::regex_replace`;  shortcut `R` is `boost::regex`

----------------------------------------------------------------------------
echo \
'1 -
2
3 none
4 abc'  |   scc -p 'F1=RR(F1,R("^(none|-)?$"),"n/a");'
1 n/a
2 n/a
3 n/a
4 abc
----------------------------------------------------------------------------


/////////////////////////////////
 echo -e '11 222222222222\n1111111111 22' |scc -n 'FMT("%s %|20t| %s") %F[0] %F[1]'
///////////////////////////////////


See full docs at http://volnitsky.com/project/scc[]
