// vim:set ft=asciidoc:
SCC — Simple CC  
===============

// (aka Snippet C++ Compiler)

A bash wrapper for _GCC_ which serve as _+++C++ +++_ snippet evaluator or as something
similar to _AWK_ with _+++C++ +++_ syntax.  You need _>=GCC-4.6.0_ and _BOOST_ for all
features to work.  For _GCC_ older than 4.4.4, remove
`-std=gnu++0x` from `CXXFLAGS` variable  (top of `scc` file).  Examples:

_+++C++ +++_ expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If snippet have bash special characters,  it must be in single or double quotes:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc 'sin(0.5)'						
0.479426
----------------------------------------------------------------------------

Now example of multi-statement and with explicit printing.
Note trailing semicolon - meaning do not print last statement-expression:

----------------------------------------------------------------------------
scc 'float x=0.5;  cout << x << " " << sin(x) << endl;'			
0.5 0.479426
----------------------------------------------------------------------------

_SCC_ includes `simple.h` which has a lot of shortcuts (à la _Google CodeJam_).  You don't
have to use these, plain _+++C++ +++_ will work too. 

Same as previous example, but with _SCC's_ bar-print (replaces `std::cout`). 
See http://volnitsky.com/project/scc/#_simplified_printing[bar-print description] for details. 

----------------------------------------------------------------------------
scc 'float x=0.5;  __ x ^ sin(x);'			
0.5 0.479426
----------------------------------------------------------------------------

Square an array.  +++C++0x+++ is on by default.  Current (>=4.6.0) _GCC_ is needed for this example. 
STL containers are printable. Typedef `vint` is `std::vector<int>`: 

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(int& v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Word frequencies (typedef `S` is `std::string`):

----------------------------------------------------------------------------
echo aa bb aa | scc 'S w;  map<S,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------

Sum-up _DF(1)_ used-disk-space column.
Shortcut `WRL` is  `while(read_line())`.  
Cass `F` derived from `deque<str>`.  Every input line is split into `F`.
Type `str` can be directly converted to/from numeric types.
The `F` member function  `operator()`  is safe version of `operator[]`.

----------------------------------------------------------------------------
df  |  scc 'int n=0;  WRL n+=F(2);  n'
31399199
----------------------------------------------------------------------------

Prepend line number to every line.
Option -p is similar to PERL's;  `NR` - number of record; 

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |  scc -p 'F.push_front(NR);'
0 aaa
1 bbb
----------------------------------------------------------------------------

Another way for doing the same. Note no trailing semicolon:

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
0 aaa
1 bbb
----------------------------------------------------------------------------

Make comma separated fields out of space separated.  Option `-o` sets `OFS`
(output field separator).  Snippet is absent in this example.

----------------------------------------------------------------------------
echo 1 2 3 |  scc -o '","' -p
1,2,3
----------------------------------------------------------------------------

Read CSV file with quoted fields (spaces, commas and escaped quotes in field are allowed):
Option `-i` sets `IFS` (input field separator); `CSV` - predefined regex constant.
How to make your own regexes  for `IFS`  - look in `scc.h`

----------------------------------------------------------------------------
echo '"aa",  "bb\"-, bb",  "cc"'   |   scc -i CSV  -o '"\n"' -p
aa
bb\"-, bb
cc
----------------------------------------------------------------------------

Replace `"-"`, `"none"` and empty fields with `"n/a"` in 2nd column with `boost::regex`. 
Boost use in _SCC_ is optional, it will be used if `/usr/include/boost` exist.
`RR` is shortcut for `boost::regex_replace`;  `R` - `boost::regex`

----------------------------------------------------------------------------
echo \
'1 -
2
3 none
4 abc'  |   scc -p 'F(1)=RR(F(1),R("^(none|-)?$"),"n/a");'
1 n/a
2 n/a
3 n/a
4 abc
----------------------------------------------------------------------------


/////////////////////////////////
 echo -e '11 222222222222\n1111111111 22' |scc -n 'FMT("%s %|20t| %s") %F[0] %F[1]'
///////////////////////////////////


See full docs at http://volnitsky.com/project/scc[]
