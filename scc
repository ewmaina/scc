#!/bin/bash

[ -f /etc/scc ]  && . /etc/scc
[ -f   ~/.scc ]  && .   ~/.scc
[ -f     .scc ]  && .     .scc

#### get GCC version
: ${GCC_PATH? must be defined}
gcc_ver=${GCC_PATH##*/}

if [[ $gcc_ver =~ ^([[:digit:]])*.([[:digit:]]) ]]  ;   then
	gcc_ver_num=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
fi

#####################################################################################

if [[ -z "$CXXFLAGS" ]] ;  then 
	CXXFLAGS+=" -Wall  -pipe "
fi

if [[ $gcc_ver_num > 43 ]] ;  then 
	CXXFLAGS+=" -std=gnu++11 "
fi 

SCC_HOME=$(dirname $(readlink -f $0))
CXXFLAGS+=" -I $SCC_HOME -I ${SCC_HOME%/*} "

prg=/tmp/$USER-scc
src=$SCC_HOME/scc.cc
snippet_h=/tmp/snippet.h
rm -f $prg $snippet_h
execute=1

usage_exit() {
	echo "
	usage:  scc  [options]  snippet  [files|args] 
		
		-n 		- for each line: read line; split into fields; execute snippet 
		-p 		- for each line: read line; split into fields; execute snippet;  output fields
		-f filename 	- get snippet from filename
		-i ifs 		- sets simple (not regex)  IFS (input field separator).
		-F ifs 		- sets simple (not regex)  IFS (input field separator).
		-o ofs 		- sets OFS (output field separator) 
		-x filename	- save executable to file and do not execute it
		-O 		- optimized compile
		-g 		- debug compile
		-H 		- read header 
	"
	exit 0
}

####################################################################################### OPTIONS 

[[  $1 ]]  ||  usage_exit

while getopts npf:vBi:F:o:x:OgHt opt;  do
	case $opt in
		#n)	n_opt=1;  is_stream=1;;
		n)	CXXFLAGS+=" -Dscc_N  -Dscc_IS_STREAM ";	 n_opt=1;  is_stream=1;;
		#p)	p_opt=1;  is_stream=1;;
		p)	CXXFLAGS+=" -Dscc_P  -Dscc_IS_STREAM ";  p_opt=1;  is_stream=1;;
		f)	snippet_file=$OPTARG;;
		v)	verbose=1;;
		I)	CXXFLAGS+=" -Dscc_IFS=$OPTARG ";; 
		x)	execute=0;  prg=$OPTARG;;
		i|F)	if [[ $OPTARG =~ '"' ]];  then  CXXFLAGS+=" -Dscc_ifs=$OPTARG "
						  else  CXXFLAGS+=" -Dscc_ifs=\"$OPTARG\" ";  fi;; 
		o)	if [[ $OPTARG =~ '"' ]];  then  CXXFLAGS+=" -Dscc_OFS=$OPTARG "
						  else  CXXFLAGS+=" -Dscc_OFS=\"$OPTARG\" ";  fi;; 
		O) 	CXXFLAGS+="-O3 -march=native";;
		g) 	CXXFLAGS+="-O0 -ggdb -D_GLIBCXX_DEBUG  -fdelete-null-pointer-checks -ftrapv -fbounds-check";;
		H)	CXXFLAGS+=" -Dscc_HEADER "; ;;
		t)	time="time -f'\t%E wall  ==  (%U+%S)        %M KB\n"; CXXFLAGS+="-O3 -march=native";;
		?) 	usage_exit;;
	esac
done

[[ $is_stream && $gcc_ver_num < 44   ]]   &&   { echo "scc error: stream ops not supported for older gcc"; exit 1; }

# shift out snippet arg
[[ -z $snippet_file ]]  &&  shift $((OPTIND-1))


#####################################################################################  PARSE SNIPPET
#echo -e ' A;\n B; A\n A\n B; A\n {}A\n B({A})\n'|tee /dev/tty|   sed 's/\({[^}]*}\)\{0\}\(\(\((.*)\)\|[^;]\)\+$\)/cout << ( \2 );/'
#echo "$@" | sed 's/\(.*[;}]\)*\([^;}]\+$\)/\1 cout << ( \2 );/' >> $src


print_last="`echo \"${1%% }\" | sed -n 's/\(.*[;}]\)*\([^;}]\+$\)/1/p'`"
CXXFLAGS+="${print_last:+ -Dscc_PRINT_LAST }"

if [[ $verbose ]] ; then 
	echo -n "expression: $1             "
	echo -n "gcc-v: `(gcc -v  2>&1) | sed -n '/^gcc version/s/^gcc version \([.0-9]*\) .*/\1/p'`            "
	echo -n "options:   ${print_last:+print-last}            "
	echo "CXXFLAGS:  ${CXXFLAGS}"
fi 

if [[ $snippet_file ]]    
then	snippet="`cat  $snippet_file | sed    's/$//;s/[ \t]*$//;s/\(.*[;}]\)*\([^;}]\+$\)/\1 cout << ( \2 );/'`";
else	snippet="`echo \"${1%% }\"   | sed    's/$//;s/[ \t]*$//;s/\(.*[;}]\)*\([^;}]\+$\)/\1 cout << ( \2 );/'`";
fi

[[ $n_opt       && $print_last ]]	&& snippet+="cout << endl;"
[[ ! $is_stream && $print_last ]]	&& snippet+="cout << endl;"


#####################################################################################  GENERATE SRC

echo  "$snippet" > /tmp/snippet.h



${CXX-g++} $CXXFLAGS $src -o $prg $LIBS || exit 1
	
if  [[ $execute == 1 ]]  ; then 
	LCC_ALL=C $time $prg "$@"
	exit $?
else
	exit 0
fi

# vim:set ts=8 sw=8 syntax=sh:   
