
include::/tmp/t.ad[]

In `scc` shall script:

* +++ C++ +++ snippet is decorated with usual boilerplate
* `simple.h`, `scc.h` and `ch.h` are included
* if `/usr/include/boost` is exist then `boost/regex.hpp` is included
* If last (or only) statement (should be an expression) is not terminated by  `;` it is sent to `std::cout`.
* if stream options are used (-n or -p), then one line is read from `std::cin` per input cycle.
	Line split into fields and snippet is executed.
	If `-p` then  line is reassembled back from fields  and sent to `std::cout`
* Generated source compiled and executed.

== SCC.H

Defines:

* F — derived from  deque<str>
* read_line()
* type str
* SCC specific shortcuts

Predefined variables (similar to AWK's):

* line	-  `std::string`,  set if with `-n` / `-p` options  or after `read_line()`
* F	-  derived from  `std::deque<str>` — line's fields; accessible like `F(i)`; counted from 0
* NF	-  `int`,  number of fields (set after read_line())
* NR 	-  `int`,  number of records (set after read_line())
* OFS 	-  `std::string`, output field separator 
* IFS 	-  `std::string`, input field separator.  
* CSV 	-  `const char[]`,  predefined regex for IFS

The `::str` type is derived from `std::string` and can be directly converted
to/from numeric types:

--------------------------------
str  s("1");
int  i;
i = s;		// 1
i = s+1;	// 2
s = 1;		// "1"
s++		// "2"
s + " m/s"	// "2 m/s"
s + 5		// "7"
---------------------------------

== SIMPLE.H

This include was initially created for use in small, one-file C++ programs.
For something like Google CodeJam. Now it is (optinal) part of SCC project,
but it still can be used independently.  

=== Everything is included

Most of STL's includes are included with `using
std::...` for most common objects. On my 4yr old laptop (no SSD), run time
with cold cache - 2s, with warm cache  <1s.

=== Simplified printing. 

In C++ something like numbers or strings are printable objects.  C-arrays  or
STL containers (including sets, maps, pairs, tuples) are not printable.
Simple.h makes all these printable too (C-array must have const-size).
Container of containers are also printable. 

Syntax `cout << ...` was replaced with bar (underline) print.
In comments -  equivalent code:

--------------------------------------------------------------------
_ x;				//  cout << x;
__ x;				//  cout << x << endl;
__ x,y;				//  cout << x << y << endl;
__ x^y;				//  cout << x << " " << y << endl;
__ "list:" ^ x ^ y;		//  cout << "list: "  << x << " " << y << endl;

vint V{1,2,3}; 			//  vector<int> V{1,2,3};
_ V;				//  for (auto it=V.begin(); ....
				//  prints: {1, 2, 3}
-------------------------------------------------------------------

TIP:  All these _ operators: `","`, `^`  and `<<`  unfortunately have different
precedence.  So `scc '_ 1,2^3;'`  is actually `scc '_ 1,(2^3);'` and it will
print only two numbers. Precedence
from highest to lowest: `<<`, `^`,  `","`.     This
problem was present in plain `std::cout` statements too. 
Workarounds are:  use parenthesis or use separate `_` statements.  


=== Simplified input

Object `in` can be used in initialiser expression. When a value
is read from `in`, it reads from `cin`. 

--------------------------------------------------------------------
int i(in);			//  int i;  cin >> i;	
--------------------------------------------------------------

For aggregate types, we need somehow to tell how many elements to read. 
One way is to have an aggregate with non zero length:

--------------------------------------------------------------------
vint V(10);			//  vector<int> V(10);
cin >> V;			//  for(size_t i=0; i<V.size(); i++)  cin >> V[i];
--------------------------------------------------------------------

Another way to do the same:

--------------------------------------------------------------------
vint V = in(10);
--------------------------------------------------------------------

Google CodeJam often have input format to input an array where first goes a
number (N) followed by N elements of an array.  To read it, we can use:

--------------------------------------------------------------------
int  N(in);			//  int N;  cin >> N;
vint V = in(N);			//  vector<int> V(N);  for(int i=0; i<N; i++)  cin >> V[i];
--------------------------------------------------------------------

Or even shorter:

--------------------------------------------------------------------
vint V = in(in);
--------------------------------------------------------------------

ALERT: Object `in` does not check for EOF. Use only in context where you do not expect
EOF (like in Google CodeJam). In production code you need to always check for EOF. 



== Utility functions

=== min/max finction
Functions `min`/`max` which will work with mixed types. Expression
`std::max(10, V.size())` - won't compile (you need to use `(size_t)10`).


=== push_back()/push_front() replacement

------------------------------------
dint D; 			//  deque<int> D;
1 >> D;				//  D.push_front(1);
D << 2 << 3 << 4;		//  D.push_back(2);  D.push_back(3)
_ D; 				//  cout << D;
				//  prints:  {1,2,3}

-----------------------------------


== CJ.H  — shortcuts


This is very similar to to what is found in typical CodeJam  source - shortcut
(macros and typedefs).  These are to squeeze C++ verbosity for one-liner
context. 

See http://github.com/lvv/scc/blob/master/cj.h[cj.h source] for full list.


WARNING: cj.h is not  recommended for anything more serious than simple,
one-file programs.  SCC does not use it internally,  you can comment it out. 
These are ugly hacks, full of side effect and name-pollution.
If used outside of `scc`, it must be included last (otherwise name collisions are guaranteed).


== Install

-----------------------------------------
git clone http://github.com/lvv/scc
PATH+=":$PWD/scc" 
echo PATH+=":$PWD/scc" >> ~/.profile
---------------------------------------
///////////////////////////////////////////////
== status
capability		|  C++200?	|	>=GCC-4.4.4	|  >=GCC-4.4.4 && Boost

expression evaluation	|	Y	|	Y		| 	Y
stl container print	|	N 	|	Y		|	Y
c-array print		| 	N 	|	N		| 	Y
stream filter		| 	Y 	|	Y		| 	Y
regex			| 	N 	|	N		| 	Y
///////////////////////////////////////////////

== TODO

* Regex which parse out last statement (for sending it to std::cout) just looks for ';', so it won't work correctly for:

- '{ code-block; } expr'
- string literals with '"(){}' charactes. +
Simple workaround: use semicolon before last statement.

* All (now only part) of STL should included;
* All (now only part) of STL containers should be printable;
* Is it possible to make `C++0x` literal for regex?  Ideally something
	like `/abc/` or `"abc"re` for `boost::regex("abc")`. 
* No speed optimzation was done yet.  



== Refs 

* http://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/introduction_and_overview.html[Boost.Regex]
* http://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html[Perl Regular Expression Syntax]
* http://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/ref/regex_token_iterator.html[regex_token_iterator]
* http://www.boost.org/doc/libs/1_46_0/libs/format/doc/format.html#examples[Boost.Fromat]
