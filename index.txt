include::/tmp/t.ad[]

== SCC parts

=== SCC
In `scc` shall script:

* +++ C++ +++ snippet is decorated with usual boilerplate
* `simple.h`, `scc.h` and `cj.h` are included
* If last (or only) statement (should be an expression) is not terminated by  `;` it is sent to `std::cout`.
* if stream options are used (-n or -p), then one line is read from `std::cin` per input cycle.
	Line split into fields and snippet is executed.
	If `-p` then  line is reassembled back from fields  and sent to `std::cout`
* Generated source compiled and executed.

=== SCC.H

Defines SCC's specific objects.   All other includes can be used independtly:

* `F` — derived from  deque<fld>
* `read_line()`
* type `fld`
* SCC specific shortcuts

Predefined variables (similar to AWK's):

* `F`	-  derived from  `std::deque<fld>` — line's fields; accessible like `F(i)`; index starts at  1
* `NF`	-  `long`,  number of fields (set after read_line())
* `NR` 	-  `long`,  number of records (set after read_line())
* `OFS`	-  `strr`, output field separator 
* `FS` 	-  `strr`, input field separator.  
* `ORS`	-  `strr`, output record separator 
* `RS` 	-  `strr`, input record separator.  

The `::fld` type is custom string type which can be directly converted
to/from numeric types:

--------------------------------
fld   f("1");
int     i;

i = f;		// 1
i = f+1;	// 2
f = 2;		// "s"
f + " m/s"	// "2 m/s"
f + 5		// "7"
---------------------------------

=== SIMPLE.H

This include was initially created for use in small, one-file _+++C++ +++_ programs.
For something like Google CodeJam.

All of STL's includes are included with `using std::...`
for most common objects. As are some C:  math.h string.h.

Now it is (optimal) part of _SCC_ project, but it still can be used independently.  


=== PRINT.H - simplified console printing. 

==== Bar __ print

Syntax `cout << ...` can be  replaced with bar (underline) print. New 
`operator,` prints also separator " " between items. 

--------------------------------------------------------------------
_  x;				//  cout << x;
__ x;				//  cout << x << endl;
__ x << y;			//  cout << x << y << endl;
__ x, y;			//  cout << x << " " << y << endl;
-------------------------------------------------------------------

==== Everything is printable

In _+++C++ +++_ something like numbers or strings are printable objects.  C-arrays  or
STL containers (including sets, maps, pairs, tuples) are not printable.
The `print.h` makes all these printable too. Container of containers are also printable. 
In comments is equivalent code:

--------------------------------------------------------------------
vint V{1,2,3}; 				//  vector<int> V{1,2,3};
_ V; 					//  cout << "{"; 
					//  for(auto it=V.begin(); it!=V.end()-1; it++)
					//       cout << *it << ", ";  if(!V.empty()) cout << V.back(); 
					//  cout << "}";
					//  prints: {1, 2, 3}

tuple<int,int>    T  {1,2};            _ T;	//  ⟨1, 2⟩
map<int,int>   	  M  {{1,1},{2,2}};    _ M;	//  {⟨1,1⟩, ⟨2,2⟩} 
vector<vint>   	  VV {{1,1}, {2,2}};   _ VV;	//  {{1, 1}, {2, 2}}
-------------------------------------------------------------------



/////////////////////////
Bar-print is actually just macros:

-------------------------------------------
#define         _    out()   << 
#define         __   outln() << 
--------------------------------------------

If you will use class `out` or `outln` directly, you can specify separator in
CTOR argument:

------------------------------------------------
x = y = z = 1;
outln(", ") << x, y, z;		//  cout << x << ", " << y ", " << z << endl;
				//  prints:  1, 1, 1


vint V{1,2,3};			//  vector<int> V{1,2,3}
out(",", "[]") << V;		//  cout << "["; 
				//  for(size_t i=0; i<V.size(); i++) 
				// 	cout <<  V[i] << (i<V.size()-1 ? "," : "");
				//  cout << "]";
				//  prints: [1,2,3]
-----------------------------------------------
///////////////////////////////


==== OI - generic output iterator

Standard library include `std::ostream_iterator`, unlike `std::cout` it accept
only one specific type and it is not pre-declared object.   So to use it with
STL algorithms, you need call its verbose constructor.

Let say we have `vector<int> V;` and `set<string> S;` and we want
copy these to `cout`.  With standard library:

------------------------------------------------------------------
copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));
copy(S.begin(), S.end(), ostream_iterator<int>(cout, " "));
-------------------------------------------------------------------

With print.h

-------------------------------------------------------------------
copy(V.begin(), V.end(), oi);
copy(S.begin(), S.end(), oi);
-------------------------------------------------------------------

File `print.h` can be used as standalone, independent include. 


==== Simplified input

Pre-declared object `in` can be used in initialiser expression. When a value
is read from `in`, it reads from `cin`. 

--------------------------------------------------------------------
int i(in);			//  int i;  cin >> i;	
float x = 1.1 + float(in)	//  float y;  cin >> y;   float x = 1.1 + y;
--------------------------------------------------------------

For aggregate types, we can specify how many elements to read. 
One way to do this is to have an aggregate with non zero length:

--------------------------------------------------------------------
vint V(10);			//  vector<int> V(10);
cin >> V;			//  for(size_t i=0; i<V.size(); i++)  cin >> V[i];
--------------------------------------------------------------------

Another way to do the same:

--------------------------------------------------------------------
vint V = in(10);
--------------------------------------------------------------------

Google CodeJam often have input format to input an array where first goes a
number (N) followed by N elements of an array.  To read it, we can use:

--------------------------------------------------------------------
int  N(in);			//  int N;  cin >> N;
vint V = in(N);			//  vector<int> V(N);  for(int i=0; i<N; i++)  cin >> V[i];
--------------------------------------------------------------------

Or even shorter:

--------------------------------------------------------------------
vint V = in(in);		// 1st will be evaluated 'in' in parenthesis, 2nd -  'in.operator()()'
--------------------------------------------------------------------

If aggregate have zero length (is empty), container is filled up until EOF. 

--------------------------------------------------------------------
echo 1 2 3 | scc 'vint V = in;  V' 	// Note:  we can not use:  vint V(in);
{1,2,3} 
--------------------------------------------------------------------


WARNING: Object `in` does not check for EOF. With scalar objects use only in
context where you can ignore or do not expect EOF (like in Google CodeJam).


/////////////////////////////
=== Utility functions

==== min/max function
Functions `min`/`max` which will work with mixed types. Expression
`std::max(10, V.size())` - won't compile (you need to use `(size_t)10`).


==== push_back()/push_front() replacement

------------------------------------
dint D; 			//  deque<int> D;
1 >> D;				//  D.push_front(1);  
D << 2 << 3 << 4;		//  D.push_back(2);  D.push_back(3);  D.push_back(4);
_ D; 				//  cout << "{";  for(auto it=D.begin(); it!=D.end()-1; it++) cout << *it << ", ";  if(!D.empty()) cout << D.back();  cout << "}";
				//  prints:  {1,2,3,4}

-----------------------------------
//////////////////////////////////////


///////////////////////////////////////////////
=== CJ.H  — shortcuts


This is very similar to to what is found in typical CodeJam  source - shortcut
(macros and typedefs).  These are to squeeze _+++C++ +++_ verbosity for one-liner
context. 

See http://github.com/lvv/scc/blob/master/cj.h[cj.h source] for full list.


WARNING: cj.h is not  recommended for anything more serious than simple,
one-file programs.  _SCC_ does not use it internally,  you can comment it out. 
These are ugly hacks, full of side effect and name-pollution.
If used outside of `scc`, it must be included last (otherwise name collisions are guaranteed).


== status
capability		|  C++200?	|	>=GCC-4.4.4	|  >=GCC-4.4.4 && Boost

expression evaluation	|	Y	|	Y		| 	Y
stl container print	|	N 	|	Y		|	Y
c-array print		| 	N 	|	N		| 	Y
stream filter		| 	Y 	|	Y		| 	Y
regex			| 	N 	|	N		| 	Y
///////////////////////////////////////////////


== Refs 

* httpx://www.johndcook.com/cpp_regex.html[Getting started with C++ TR1 * regular expressions]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/introduction_and_overview.html[Boost.Regex]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html[Perl Regular Expression Syntax]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/ref/regex_token_iterator.html[regex_token_iterator]
* httpx://www.boost.org/doc/libs/1_46_0/libs/format/doc/format.html#examples[Boost.Format]
* httpx://www.topcoder.com/stat?c=problem_solution&cr=152347&rd=4709&pm=1889[ZorbaTHut TopCoder submission]
* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial[+++C++11 +++ regex tutorial. Part-1 ]/
* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial-part-2[+++C++11 +++  regex tutorial. Part-2]/
* httpx://en.wikipedia.org/wiki/Delimiter[Delimiter]
* httpx://en.wikipedia.org/wiki/Comma-separated_values[CSV]
* httpx://home.vrweb.de/~juergen.kahrs/gawk/XML/[XMLgawk]
* httpx://en.wikipedia.org/wiki/Awk[Awk]
* httpx://people.cs.uu.nl/piet/docs/nawk/nawk_23.html[Awk: Specifying how Fields are Separated]
* httpx://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.200x[LIBSTDC++ status +++C++11+++]

////////////////

GNU AWK
	one liners -- http://www.gnu.org/s/gawk/manual/gawk.html#One_002dshot


TOKENIZER 
	http://www.codeproject.com/KB/recipes/Tokenizer.aspx
REGEX
	constexpr (at complie time) --
	http://cpptruths.blogspot.com/2011/07/compile-time-regex-matcher-using.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+CppTruths+%28C%2B%2B+Truths%29&utm_content=Google+Reader
	A Regular Expression Matcher by Rob Pike -- http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
	Writing own regular expression parser -- http://www.codeproject.com/KB/recipes/OwnRegExpressionsParser.aspx
	http://swtch.com/~rsc/regexp/
	PCRE++ http://www.linuxquestions.org/questions/showthread.php?p=4387972#post4387972
JSON
	http://www.kirit.com/Blog:/2008-03-31/Thoughts%20on%20TinyJSON
	http://www.kirit.com/Thread:/1723074
	http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
	http://stackoverflow.com/a/8560856
XML
	awk xml -- http://pastebin.com/Vwvz3gzb
	http://www.artima.com/cppsource/xml_data_binding.html
	http://www.grinninglizard.com/tinyxml/
	http://stackoverflow.com/questions/170686/best-open-xml-parser-for-c
	http://rapidxml.sourceforge.net/
	http://www.codeguru.com/cpp/data/data-misc/xml/article.php/c19341
	-----------
	There is a boost::xml in the sandbox and it's very good. We use
	TinyXML++ (which is decent) here but boost::xml was preferred; it was
	just too likely to change
ENCODING
	Boost.Unicode: Aims at providing the foundation tools to
	accurately represent and deal with natural text in C++ in a
	portable and robust manner, so as to allow internationalized
	applications, by implementing parts of the Unicode Standard.
	(see (svn.boost.org/trac/boost/wiki/…;)
		
	This is already included as part of C++03. It's
	provided by the std::codecvt facet of the locale
	library
		
	Take a look on Boost.Locale it is a part of it
DB
	SQL connectors -- http://www.reddit.com/r/cpp/comments/mrbc5/how_to_connect_to_an_sql_database/
	http://soci.sourceforge.net/
	https://svn.boost.org/trac/boost/wiki/LibrariesUnderConstruction#Boost.RDB
	http://webtoolkit.eu/wt#/blog/2009/11/26/wt__dbo__an_orm__c___style
	http://code.google.com/p/hiberlite/
	------------------
	Regarding boost::sql proposal, there is some work in progress:
	    * On BoostCon'09 Jeff Garland led workshop: Library in Week 2009 to discuss the std::rdb propsals, here are materials std::rdb (.tgz package)
	    * std_rdb - Boost sister mailing list to discuss standard rdb proposal(s)
	    * SOCI has been discussed in frame of the std::rdb mailing list and the workshop


////////////////////
