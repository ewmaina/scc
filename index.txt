include::/tmp/t.ad[]


Status
------

Current alpha version is v0.2 (use this git tag). Only GCC-4.7 (pre release) or
later is currently supported.  It might work with latest CLANG and MSVS, but it
was not tested.  Version v0.2 is about x100 times faster than v0.1 and several
times faster than GAWK/MAWK.  Boost is not used in v0.2.  Regex in RS/FS are
currently not supported (but were in v0.1) 

If you need to use it with older GCC (4.1 was supported) - use v0.1.

Install
-------

-----------------------------------------
git clone http://github.com/lvv/scc
echo PATH+=":$PWD/scc" >> ~/.profile
. ~/.profile
---------------------------------------


Overview
--------

C++ REPL
~~~~~~~~~

SCC can be used as simple REPL for +++ C++ +++.  Expression  evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If expression is not terminated with semicolon, it is sent to `std::cout`.
Same for last expression in multi-statement snippet.
If snippet have bash special characters,  it must be in single or double
quotes. If expression starts with minus, end-of-options indicator "--" must be used:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc -- -42
-42

scc 'double x=0.5;  sin(x)'						
0.479426

scc 'bitset\<64>(unsigned(-1))'
0000000000000000000000000000000011111111111111111111111111111111

echo "ABC"  |  scc 'char c;  while (cin.get(c))  cout << (char)tolower(c);'
abc
----------------------------------------------------------------------------


To squeeze C++ verbosity for SCC's one-liners, several things were done. 

Snippet is evaluated in environ where all STL includes are included and almost
all STL objects are imported into default namespace with `using std::...;`

C++ printing was replaced with so called
http://volnitsky.com/project/scc/#_simplified_printing[bar-print]
and any STL container can be simply sent to `std::cout`.
Below are bar-print statements with equivalent code in comments:

---------------------------------------------------------------
_  x;                           //  cout << x;
__ x;                           //  cout << x << endl;
__ x << y;                      //  cout << x << y << endl;
__ x, y;                        //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

Some shortcuts (typedefs and macros) were defined:

------------------------------------------------------
str	-->   std::string  
vint	-->   std::vector<int>  
WRL	-->   while(read_line())      
------------------------------------------------------

Several variables were pre-declared:

* `i`, `j`, `k`, `n`, `m` -- `long`, initialized to 0
* `x`, `y`, `z` --  `double`, initialized to 0
* `s`, `w` -- `std::string`
* `c` -- `char`

You don't need to remember these, you can
re-define these to what ever you want. 
So, in last example we could've skipped
definition `char c;`. 

More examples.  Square an array.  +++C++11 +++ is on by default:

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(auto v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Calculate words frequencies from stdin.

----------------------------------------------------------------------------
echo aa bb aa | scc 'str w;  map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------


Native AWK
~~~~~~~~~~

After initial use as simple REPL evaluator, I realised that SCC can be useful
tool for stream processing - something like native AWK.  So AWK-like capability
were incorporated into SCC.  Syntax is not exactly AWK's,  it is still +++C++ +++, 
but it is quite similar.

Biggest difference  is snippet layout. AWK's program have following elements (simplified):

----------------------------------------------------------------------------
awk 'BEGIN{begin-expr};  {per-record-expr};  END{end-expr}'
----------------------------------------------------------------------------

SCC have two alternatives for above. First is simple while-loop:

----------------------------------------------------------------------------
scc 'begin-expr;  WRL  per-record-expr;   end-expr;'
----------------------------------------------------------------------------

Shortcut `WRL` expands to `while(read_line())`.  
Function `read_line()`, reads input line and splits it into fields.

Second alternative is to use options `-n` and `-p`.
With `-n`, record is read, split into fields and snippet is evaluated for every
record.  With `-p`, additionally all fields are printed after snippet was
evaluated.  These are equivalent to PERL's and 
are convenient when we do not have `begin-expr` and `end-expr`.

----------------------------------------------------------------------------
scc -n 'per-record-expr;'
----------------------------------------------------------------------------

Fortunately,  GCC allows use of `$` in identifiers, so AWK's dollar 
variables (`$0`, `$1`, `$NF`) are valid in SCC.

In SCC, `$` variables are of special string type `fld`, it is similar to `std::string` but it can be
used in arithmetic expressions - they will be implicitly converted to corresponding numeric type. And it
can be assigned a numeric value. That is `fld` behave like AWK's vars.
Numeric types are any of `int`, `float`, etc.


More examples.  Sum-up `DF(1)` used-disk-space column.  In AWK and SCC:

----------------------------------------------------------------------------
df | awk '{n+=$3};  END{print n}'
31399199

df | scc 'WRL n+=$3;  n' 
31399199
----------------------------------------------------------------------------

We can also replace column number with symbolic name (from `df` output header):

----------------------------------------------------------------------------
df | scc -H 'WRL n+=$("Used");  n' 
31399199
----------------------------------------------------------------------------

Prepend line number to every line.

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
1 aaa
2 bbb
----------------------------------------------------------------------------

For every line: first `NR` is printed (notice that there is no semicolon), then $0.

Now lets make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator), `-F` - set `FS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -F: -o, -p
1,2,3
----------------------------------------------------------------------------

Or equivalent:

----------------------------------------------------------------------------
echo 1:2:3 | FS=: OFS=, scc -p
1,2,3
----------------------------------------------------------------------------


Replace `"-"` or  `"none"` with `"n/a"` in 2nd column using `std::regex`.  In AWK and SCC:

---------------------------------------------------------------------------
echo -e '1 -\n2 none\n3 abc'  |  awk '{gsub(/^(none|-)$/,"n/a",$2);  print $0}'
1 n/a
3 n/a
4 abc

echo -e '1 -\n2 none\n3 abc'  |  scc -p 'if ($2 == "(none|-)"_R)  $2="n/a";'
1 n/a
3 n/a
4 abc
----------------------------------------------------------------------------



C-string with `_R` suffix are `std::regex` literal.  The `operator==` calls `std::regex_match()`.
Unfortunately GCC's LIBSTDC++ not yet have working `std::regex_replace` and `std::regex_search` and we have to use `if`.


== SCC parts

=== SCC
In `scc` shall script:

* +++ C++ +++ snippet is decorated with usual boilerplate
* `simple.h`, `scc.h` and `cj.h` are included
* If last (or only) statement (should be an expression) is not terminated by  `;` it is sent to `std::cout`.
* if stream options are used (-n or -p), then one line is read from `std::cin` per input cycle.
	Line split into fields and snippet is executed.
	If `-p` then  line is reassembled back from fields  and sent to `std::cout`
* Generated source compiled and executed.

=== SCC.H

Defines SCC's specific objects.   All other includes can be used independtly:

* `F` — derived from  deque<fld>
* `read_line()`
* type `fld`
* SCC specific shortcuts

Predefined variables (similar to AWK's):

* `F`	-  derived from  `std::deque<fld>` — line's fields; accessible like `F(i)`; index starts at  1
* `NF`	-  `long`,  number of fields (set after read_line())
* `NR` 	-  `long`,  number of records (set after read_line())
* `OFS`	-  `strr`, output field separator 
* `FS` 	-  `strr`, input field separator.  
* `ORS`	-  `strr`, output record separator 
* `RS` 	-  `strr`, input record separator.  

The `::fld` type is custom string type which can be directly converted
to/from numeric types:

--------------------------------
fld   f("1");
int     i;

i = f;		// 1
i = f+1;	// 2
f = 2;		// "s"
f + " m/s"	// "2 m/s"
f + 5		// "7"
---------------------------------

=== SIMPLE.H

This include was initially created for use in small, one-file _+++C++ +++_ programs.
For something like Google CodeJam.

All of STL's includes are included with `using std::...`
for most common objects. As are some C:  math.h string.h.

Now it is (optimal) part of _SCC_ project, but it still can be used independently.  


=== PRINT.H - simplified console printing. 

==== Bar __ print

Syntax `cout << ...` can be  replaced with bar (underline) print. New 
`operator,` prints also separator " " between items. 

--------------------------------------------------------------------
_  x;				//  cout << x;
__ x;				//  cout << x << endl;
__ x << y;			//  cout << x << y << endl;
__ x, y;			//  cout << x << " " << y << endl;
-------------------------------------------------------------------

==== Everything is printable

In _+++C++ +++_ something like numbers or strings are printable objects.  C-arrays  or
STL containers (including sets, maps, pairs, tuples) are not printable.
The `print.h` makes all these printable too. Container of containers are also printable. 
In comments is equivalent code:

--------------------------------------------------------------------
vint V{1,2,3}; 				//  vector<int> V{1,2,3};
_ V; 					//  cout << "{"; 
					//  for(auto it=V.begin(); it!=V.end()-1; it++)
					//       cout << *it << ", ";  if(!V.empty()) cout << V.back(); 
					//  cout << "}";
					//  prints: {1, 2, 3}

tuple<int,int>    T  {1,2};            _ T;	//  ⟨1, 2⟩
map<int,int>   	  M  {{1,1},{2,2}};    _ M;	//  {⟨1,1⟩, ⟨2,2⟩} 
vector<vint>   	  VV {{1,1}, {2,2}};   _ VV;	//  {{1, 1}, {2, 2}}
-------------------------------------------------------------------



/////////////////////////
Bar-print is actually just macros:

-------------------------------------------
#define         _    out()   << 
#define         __   outln() << 
--------------------------------------------

If you will use class `out` or `outln` directly, you can specify separator in
CTOR argument:

------------------------------------------------
x = y = z = 1;
outln(", ") << x, y, z;		//  cout << x << ", " << y ", " << z << endl;
				//  prints:  1, 1, 1


vint V{1,2,3};			//  vector<int> V{1,2,3}
out(",", "[]") << V;		//  cout << "["; 
				//  for(size_t i=0; i<V.size(); i++) 
				// 	cout <<  V[i] << (i<V.size()-1 ? "," : "");
				//  cout << "]";
				//  prints: [1,2,3]
-----------------------------------------------
///////////////////////////////


==== OI - generic output iterator

Standard library include `std::ostream_iterator`, unlike `std::cout` it accept
only one specific type and it is not pre-declared object.   So to use it with
STL algorithms, you need call its verbose constructor.

Let say we have `vector<int> V;` and `set<string> S;` and we want
copy these to `cout`.  With standard library:

------------------------------------------------------------------
copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));
copy(S.begin(), S.end(), ostream_iterator<int>(cout, " "));
-------------------------------------------------------------------

With print.h

-------------------------------------------------------------------
copy(V.begin(), V.end(), oi);
copy(S.begin(), S.end(), oi);
-------------------------------------------------------------------

File `print.h` can be used as standalone, independent include. 


==== Simplified input

Pre-declared object `in` can be used in initialiser expression. When a value
is read from `in`, it reads from `cin`. 

--------------------------------------------------------------------
int i(in);			//  int i;  cin >> i;	
float x = 1.1 + float(in)	//  float y;  cin >> y;   float x = 1.1 + y;
--------------------------------------------------------------

For aggregate types, we can specify how many elements to read. 
One way to do this is to have an aggregate with non zero length:

--------------------------------------------------------------------
vint V(10);			//  vector<int> V(10);
cin >> V;			//  for(size_t i=0; i<V.size(); i++)  cin >> V[i];
--------------------------------------------------------------------

Another way to do the same:

--------------------------------------------------------------------
vint V = in(10);
--------------------------------------------------------------------

Google CodeJam often have input format to input an array where first goes a
number (N) followed by N elements of an array.  To read it, we can use:

--------------------------------------------------------------------
int  N(in);			//  int N;  cin >> N;
vint V = in(N);			//  vector<int> V(N);  for(int i=0; i<N; i++)  cin >> V[i];
--------------------------------------------------------------------

Or even shorter:

--------------------------------------------------------------------
vint V = in(in);		// 1st will be evaluated 'in' in parenthesis, 2nd -  'in.operator()()'
--------------------------------------------------------------------

If aggregate have zero length (is empty), container is filled up until EOF. 

--------------------------------------------------------------------
echo 1 2 3 | scc 'vint V = in;  V' 	// Note:  we can not use:  vint V(in);
{1,2,3} 
--------------------------------------------------------------------


WARNING: Object `in` does not check for EOF. With scalar objects use only in
context where you can ignore or do not expect EOF (like in Google CodeJam).


/////////////////////////////
=== Utility functions

==== min/max function
Functions `min`/`max` which will work with mixed types. Expression
`std::max(10, V.size())` - won't compile (you need to use `(size_t)10`).


==== push_back()/push_front() replacement

------------------------------------
dint D; 			//  deque<int> D;
1 >> D;				//  D.push_front(1);  
D << 2 << 3 << 4;		//  D.push_back(2);  D.push_back(3);  D.push_back(4);
_ D; 				//  cout << "{";  for(auto it=D.begin(); it!=D.end()-1; it++) cout << *it << ", ";  if(!D.empty()) cout << D.back();  cout << "}";
				//  prints:  {1,2,3,4}

-----------------------------------
//////////////////////////////////////


///////////////////////////////////////////////
=== CJ.H  — shortcuts


This is very similar to to what is found in typical CodeJam  source - shortcut
(macros and typedefs).  These are to squeeze _+++C++ +++_ verbosity for one-liner
context. 

See http://github.com/lvv/scc/blob/master/cj.h[cj.h source] for full list.


WARNING: cj.h is not  recommended for anything more serious than simple,
one-file programs.  _SCC_ does not use it internally,  you can comment it out. 
These are ugly hacks, full of side effect and name-pollution.
If used outside of `scc`, it must be included last (otherwise name collisions are guaranteed).


== status
capability		|  C++200?	|	>=GCC-4.4.4	|  >=GCC-4.4.4 && Boost

expression evaluation	|	Y	|	Y		| 	Y
stl container print	|	N 	|	Y		|	Y
c-array print		| 	N 	|	N		| 	Y
stream filter		| 	Y 	|	Y		| 	Y
regex			| 	N 	|	N		| 	Y
///////////////////////////////////////////////


== Refs 

* httpx://www.johndcook.com/cpp_regex.html[Getting started with C++ TR1 * regular expressions]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/introduction_and_overview.html[Boost.Regex]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html[Perl Regular Expression Syntax]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/ref/regex_token_iterator.html[regex_token_iterator]
* httpx://www.boost.org/doc/libs/1_46_0/libs/format/doc/format.html#examples[Boost.Format]
* httpx://www.topcoder.com/stat?c=problem_solution&cr=152347&rd=4709&pm=1889[ZorbaTHut TopCoder submission]
* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial[+++C++11 +++ regex tutorial. Part-1 ]/
* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial-part-2[+++C++11 +++  regex tutorial. Part-2]/
* httpx://en.wikipedia.org/wiki/Delimiter[Delimiter]
* httpx://en.wikipedia.org/wiki/Comma-separated_values[CSV]
* httpx://home.vrweb.de/~juergen.kahrs/gawk/XML/[XMLgawk]
* httpx://en.wikipedia.org/wiki/Awk[Awk]
* httpx://people.cs.uu.nl/piet/docs/nawk/nawk_23.html[Awk: Specifying how Fields are Separated]
* httpx://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.200x[LIBSTDC++ status +++C++11+++]

////////////////

GNU AWK
	one liners -- http://www.gnu.org/s/gawk/manual/gawk.html#One_002dshot


TOKENIZER 
	http://www.codeproject.com/KB/recipes/Tokenizer.aspx
REGEX
	constexpr (at complie time) --
	http://cpptruths.blogspot.com/2011/07/compile-time-regex-matcher-using.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+CppTruths+%28C%2B%2B+Truths%29&utm_content=Google+Reader
	A Regular Expression Matcher by Rob Pike -- http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
	Writing own regular expression parser -- http://www.codeproject.com/KB/recipes/OwnRegExpressionsParser.aspx
	http://swtch.com/~rsc/regexp/
	PCRE++ http://www.linuxquestions.org/questions/showthread.php?p=4387972#post4387972
JSON
	http://www.kirit.com/Blog:/2008-03-31/Thoughts%20on%20TinyJSON
	http://www.kirit.com/Thread:/1723074
	http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
	http://stackoverflow.com/a/8560856
XML
	awk xml -- http://pastebin.com/Vwvz3gzb
	http://www.artima.com/cppsource/xml_data_binding.html
	http://www.grinninglizard.com/tinyxml/
	http://stackoverflow.com/questions/170686/best-open-xml-parser-for-c
	http://rapidxml.sourceforge.net/
	http://www.codeguru.com/cpp/data/data-misc/xml/article.php/c19341
	-----------
	There is a boost::xml in the sandbox and it's very good. We use
	TinyXML++ (which is decent) here but boost::xml was preferred; it was
	just too likely to change
ENCODING
	Boost.Unicode: Aims at providing the foundation tools to
	accurately represent and deal with natural text in C++ in a
	portable and robust manner, so as to allow internationalized
	applications, by implementing parts of the Unicode Standard.
	(see (svn.boost.org/trac/boost/wiki/…;)
		
	This is already included as part of C++03. It's
	provided by the std::codecvt facet of the locale
	library
		
	Take a look on Boost.Locale it is a part of it
DB
	SQL connectors -- http://www.reddit.com/r/cpp/comments/mrbc5/how_to_connect_to_an_sql_database/
	http://soci.sourceforge.net/
	https://svn.boost.org/trac/boost/wiki/LibrariesUnderConstruction#Boost.RDB
	http://webtoolkit.eu/wt#/blog/2009/11/26/wt__dbo__an_orm__c___style
	http://code.google.com/p/hiberlite/
	------------------
	Regarding boost::sql proposal, there is some work in progress:
	    * On BoostCon'09 Jeff Garland led workshop: Library in Week 2009 to discuss the std::rdb propsals, here are materials std::rdb (.tgz package)
	    * std_rdb - Boost sister mailing list to discuss standard rdb proposal(s)
	    * SOCI has been discussed in frame of the std::rdb mailing list and the workshop


////////////////////
