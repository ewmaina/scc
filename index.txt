include::/tmp/t.ad[]


C++ REPL
--------

Expression evaluated and printed:

----------------------------------------------------------------------------
scc 2+2								
4
----------------------------------------------------------------------------

If expression is not terminated with semicolon, it is sent to `std::cout`.
Same for last expression in multi-statement snippet.
If snippet have bash special characters,  it must be in single or double
quotes. If expression starts with minus, end-of-options indicator `--` must be used:

----------------------------------------------------------------------------
scc '"hello world"'
hello world

scc -- -42
-42

scc 'double x=0.5;  sin(x)'						
0.479426

scc 'bitset\<64>(unsigned(-1))'
0000000000000000000000000000000011111111111111111111111111111111

echo "ABC"  |  scc 'char c;  while (cin.get(c))  cout << (char)tolower(c);'
abc
----------------------------------------------------------------------------

Snippet is evaluated in environment where all STL includes are included and almost
all STL objects are imported into default namespace with `using std::...;`

If you need only plain +++C++ +++ REPL, that is about all you need to know.  You can
skip to link:#_install[Install] section now.  Sections that follow are about
SCC C++ extensions to alleviate +++C++ +++ verbosity and AWK like capabilities.


Simple IO
---------

Bar-print
~~~~~~~~~

Instead of C++ `std::cout` printing, SCC uses so called **bar-print**.

//http://volnitsky.com/project/scc/#_simplified_printing[bar-print]

Below are bar-print statements with equivalent code in comments:

---------------------------------------------------------------
_  x;                  //  cout << x;
__ x;                  //  cout << x << endl;
__ x << y;             //  cout << x << y << endl;
__ x, y;               //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

OI - Generic ostream_iterator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Standard library includes `std::ostream_iterator`. Unlike `std::cout` it
accept only one specific type (specified at construction time) and it is not
pre-defined object.   So to use it with STL algorithms, you need
call its quite verbose constructor.

Let say we have `vector<int> V;` and `set<string> S;` and we want
copy these to `std::cout`.  With standard library:

------------------------------------------------------------------
copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));
copy(S.begin(), S.end(), ostream_iterator<int>(cout, " "));
-------------------------------------------------------------------

Include `print.h` defines `oi` object, which is similarly to `std::cout`, can work with any type and
is pre-defined.  With `oi`, above example will be:

-------------------------------------------------------------------
copy(V.begin(), V.end(), oi);
copy(S.begin(), S.end(), oi);
-------------------------------------------------------------------

Assigning a container to `oi` is equivalent to doing
`std::copy`, so above example we could have also written as:

-------------------------------------------------------------------
oi = V;
oi = S;
-------------------------------------------------------------------

Containers Printing
~~~~~~~~~~~~~~~~~~

Any STL container can be also printed without `oi`.  You can just send it to
`std::cout` or to bar-print.

In comments is equivalent code:

--------------------------------------------------------------------
vint            C {1,2,3};        __ C;	   //  vector<int> C{1,2,3};
 					   //  cout << "{"; 
					   //  for(auto it=C.begin(); it!=C.end()-1; it++)
					   //       cout << *it << ", ";
					   //  if(!C.empty()) cout << C.back(); 
					   //  cout << "}\n";
					   //  prints: {1, 2, 3}
					
int             C[] {1,2,3};       __ C;   //  {1,2,3} 
array<int,3>    C {1,2,3};         __ C;   //  {1,2,3}
tuple<int,int>  C {1,2};           __ C;   //  ⟨1, 2⟩ 
map<int,int>    C {{1,1},{2,2}};   __ C;   //  {⟨1,1⟩, ⟨2,2⟩} 
vector<vint>	C {{1,1},{2,2}};   __ C;   //  {{1, 1}, {2, 2}}
-------------------------------------------------------------------


Object IN
~~~~~~~~~

Pre-defined object `in` can be used as initialiser. When a value
is read from `in`, it is acquired from `std::cin`. 

--------------------------------------------------------------------
int i(in);			//  int i;  cin >> i;	
float x = 1.1 + float(in);	//  float y;  cin >> y;   float x = 1.1 + y;
--------------------------------------------------------------

WARNING: Object `in` does not check for EOF. With scalar objects use only in
context where you can ignore or do not expect EOF.


If a container have non-zero length,  we can directly input from `std::cin`
without object `in`:

--------------------------------------------------------------------
vint V(10);		//  vector<int> V(10);
cin >> V;		//  for(size_t i=0; i<V.size(); i++)  cin >> V[i];
--------------------------------------------------------------------

Object `in` can be used to input container too, but we need somehow to
tell it how many elements needs to be read.

If container have zero length, we tell object `in` how many object to read:

--------------------------------------------------------------------
vint V = in(10);
--------------------------------------------------------------------

Google CodeJam and FaceBook Hackercup  often have input format to input an
array where first goes a number (N) followed by N elements of an array.  To
read it, we can use:

--------------------------------------------------------------------
int  N(in);		//  int N;  cin >> N;
vint V = in(N);		//  vector<int> V(N);  for(int i=0; i<N; i++)  cin >> V[i];
--------------------------------------------------------------------

Or even shorter:

--------------------------------------------------------------------
vint V = in(in);	// 1st will be evaluated 'in' in parenthesis, 2nd -  'in.operator()()'
--------------------------------------------------------------------

If container have zero length (is empty) and we didn't specified how many
elements to read, container is filled up until EOF. 

--------------------------------------------------------------------
echo 1 2 3 | scc 'vint V = in;  V' 	// Note:  we can not use:  vint V(in);
{1,2,3} 
--------------------------------------------------------------------



print.h standalone use
~~~~~~~~~~~~~~~~~~~~~~

File `print.h` can be used as standalone, independent include. 

--------------------------------------------
#include <print.h>
int main() {
	__ "hello world";
}
-------------------------------------------

Files `simple.h`, `cj.h` and `stl.h` can also be used independently.


Simple STL
----------

This is for those who likes terse C-style code.
Below is string manipulation example.   Given `Thello world?` string, it
transforms it and prints -  `" H e l l o   w o r l d ! "`:

------------------------------------------------------
dchar  S;		  //  deque<char>  S;   

S <= "Thello world?";	  //  const char cS[]="Thello world?";
			  //  for (int i; i<(sizeof cS); i++) 
			  //       S.push_back(cS[i])

--S;			  //  S.pop_front();
S--;			  //  S.pop_back();	// '\0'
 
++S = 'H';		  //  S.front() = 'H';
S++ = '!';		  //  S.back()  = '!';

'"' >> S << '"' << '\n';  //  S.push_front('"');
			  //  S.push_back('"');
			  //  S.push_back('\n');
					
copy(+S, -S, oi);	  //  copy(S.begin(), S.end(), ostream_iterator<char>(cout, " "));
------------------------------------------------------

Note that all operators, do not create temp copy, they are modifying container itself.
Full list of container operators:

----------------------------------------------------------------
+C			//  C.begin()
-C			//  C.end()
!C			//  C.size()
++C			//  C.front()
C++			//  C.back()
--C			//  C.pop_front()
C--			//  C.pop_back()
C << x			//  C.push_back(x)
x >> C			//  C.push_front(x)
C >> x			//  x = C.back(x);   C.pop_back();
x << C			//  x = C.front(x);  C.pop_front();
C1 << C2		//  copy(C2.begin(), C2.end(), back_inserter(C1));
C1 >> C2		//  copy(C1.rbegin(), C1.rend(), front_inserter(C2)); 
C1 <= C2		//  C1.clear();  copy(C2.begin(), C2.end(), back_inserter(C1));

++Pair			//  Pair.first
Pair++			//  Pair.second

++Tuple			//  get\<0>(Tuple)
Tuple++			//  get<tuple_size<tuple<Types...> >::value-1>(Tuple) 	// last tuple element
!Tuple			//  tuple_size<decltype(Tuple) >::value

			//  STACK
S << x			//  S.push(x)
S ++ 			//  S.top(x)
S >> x			//  x = S.top(x);  S.pop()
S -- 			//  S.pop(x)

			//  QUEUE
Q << x			//  Q.push(x)
Q ++ 			//  Q.back(x)
++ Q 			//  Q.front(x)
x << Q			//  x = Q.front(x);  Q.pop()
-- Q 			//  Q.pop(x)
----------------------------------------------------------------


Shortcuts and predeclared vars
-------------------------------

Shortcuts are typedefs and macros to cut verbosity. For example:

------------------------------------------------------
str	-->   std::string  
vint	-->   std::vector<int>  
WRL	-->   while(read_line())      
------------------------------------------------------

Some variables are pre-defined:

* `i`, `j`, `k`, `n`, `m` -- `long`, initialized to 0
* `x`, `y`, `z` --  `double`, initialized to 0
* `s`, `w` -- `std::string`
* `c` -- `char`

You don't need to remember these, you can
re-define these to what ever you want. 
So, in last example we could've skipped
definition `char c;`. 


Examples
--------

Square an array.  +++C++11 +++ is on by default:

----------------------------------------------------------------------------
scc 'vint V{1,2,3};  for(auto v:V) v*=v;   V'			
{1, 4, 9}								
----------------------------------------------------------------------------

Calculate words frequencies from `stdin`. (`w` - is pre-defined `std::string`)

----------------------------------------------------------------------------
echo aa bb aa | scc 'map<str,int> M;  while(cin>>w) M[w]++;  M' 
{⟨aa,2⟩, ⟨bb,1⟩}
----------------------------------------------------------------------------




Native AWK
~~~~~~~~~~

SCC also can be used as tool for stream processing - something like native AWK. 
Syntax is not exactly AWK's,  it is still +++C++ +++, 
but it is quite similar.

Biggest difference  is script layout. AWK's script have following
elements (simplified):

----------------------------------------------------------------------------
awk 'BEGIN{begin-expr};  {per-record-expr};  END{end-expr}'
----------------------------------------------------------------------------

SCC have two alternatives for above. First is explicit while-loop:

----------------------------------------------------------------------------
scc 'begin-expr;  WRL  per-record-expr;   end-expr;'
----------------------------------------------------------------------------

Shortcut `WRL` expands to `while(read_line())`.  
Function `read_line()`, reads input line and splits it into fields.

Second alternative is to use options `-n` and `-p`.
With `-n`, record is read, split into fields and snippet is evaluated for every
record.  With `-p`, additionally all fields are printed after snippet was
evaluated.  These are equivalent to PERL's and 
are convenient when we do not have _begin-expr_ and _end-expr_.

----------------------------------------------------------------------------
scc -n 'per-record-expr;'
----------------------------------------------------------------------------

Fortunately,  GCC allows use of `$` in identifiers, so AWK's dollar 
variables (`$0`, `$1`, `$NF`) are valid in SCC.

In SCC, `$` variables are of special string type `fld`, it is similar to `std::string` but it can be
used in arithmetic expressions - they will be implicitly converted to corresponding numeric type. And it
can be assigned a numeric value. That is `fld` behave like AWK's vars.
Numeric types are any of `int`, `float`, etc.

--------------------------------
fld   f("1");
int     i;

i = f;		// 1
i = f+1;	// 2
f = 2;		// "2"
f + " m/s"	// "2 m/s"
f + 5		// "7"
---------------------------------

SCC supports following AWK's global variables:

* `$`	-  derived from  `std::deque<fld>` — line's fields
* `NF`	-  `long`,  number of fields (set after read_line())
* `NR` 	-  `long`,  number of records (set after read_line())
* `OFS`	-  `strr`, output field separator 
* `FS` 	-  `strr`, input field separator.  
* `ORS`	-  `strr`, output record separator 
* `RS` 	-  `strr`, input record separator.  
* `FILENAME` - `const char[]`, current filename being processed


More examples.  Sum-up `DF(1)` used-disk-space column.  In AWK and SCC:

----------------------------------------------------------------------------
df | awk '{n+=$3};  END{print n}'
31399199

df | scc 'WRL n+=$3;  n' 
31399199
----------------------------------------------------------------------------

We can also replace column number with symbolic name (from `df` output header):

----------------------------------------------------------------------------
df | scc -H 'WRL n+=$("Used");  n' 
31399199
----------------------------------------------------------------------------

Prepend line number to every line.

----------------------------------------------------------------------------
echo -e 'aaa\nbbb'   |   scc -p NR
1 aaa
2 bbb
----------------------------------------------------------------------------

For every line: first `NR` is printed (notice that there is no semicolon),
then `$0`.

Now lets make comma separated fields out of colon separated.  Option `-o` sets `OFS`
(output field separator), `-F` - set `FS`  Snippet is empty in this example.

----------------------------------------------------------------------------
echo 1:2:3 | scc -F: -o, -p
1,2,3
----------------------------------------------------------------------------

Or equivalent:

----------------------------------------------------------------------------
echo 1:2:3 | FS=: OFS=, scc -p
1,2,3
----------------------------------------------------------------------------


Replace `"-"` or  `"none"` with `"n/a"` in 2nd column using `std::regex`.  In AWK and SCC:

---------------------------------------------------------------------------
echo -e '1 -\n2 none\n3 abc'  |  awk '{gsub(/^(none|-)$/,"n/a",$2);  print $0}'
1 n/a
3 n/a
4 abc

echo -e '1 -\n2 none\n3 abc'  |  scc -p 'if ($2 == "(none|-)"_R)  $2="n/a";'
1 n/a
3 n/a
4 abc
----------------------------------------------------------------------------



C-string with `_R` suffix are `std::regex` literal.  The `operator==` calls `std::regex_match()`.
Unfortunately GCC's LIBSTDC++ not yet have working `std::regex_replace` and `std::regex_search` and we have to use `if`.




Install
-------

-----------------------------------------
git clone http://github.com/lvv/scc
echo PATH+=":$PWD/scc" >> ~/.profile
. ~/.profile
---------------------------------------

Current alpha version is v0.2.1, use "latest" git tag for relatively stable
version. SCC uses C+11 extensively and some GCC extensions, so currently it can
work only with GCC-4.7 (pre release).  It might work with CLANG and
MSVS, but this was not tested.  For stream ops, version v0.2.* is about x100 times faster than v0.1 and several
times faster than GAWK/MAWK.  Boost is not used in v0.2.  Regex in `RS`/`FS` are
currently not supported (but were in v0.1) 

+++ C++ +++ parser of semi-broken.  To make multi-line scripts, as workaround use semicolon
at the end of every line (even in comments).

If you need to use it with older GCC - use v0.1.





== Refs 

* httpx://www.johndcook.com/cpp_regex.html[Getting started with C++ TR1 * regular expressions]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/introduction_and_overview.html[Boost.Regex]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html[Perl Regular Expression Syntax]
* httpx://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/ref/regex_token_iterator.html[regex_token_iterator]
* httpx://www.boost.org/doc/libs/1_46_0/libs/format/doc/format.html#examples[Boost.Format]
* httpx://www.topcoder.com/stat?c=problem_solution&cr=152347&rd=4709&pm=1889[ZorbaTHut TopCoder submission]
* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial[+++C++11 +++ regex tutorial. Part-1 ]/
* httpx://solarianprogrammer.com/2011/10/20/cpp-11-regex-tutorial-part-2[+++C++11 +++  regex tutorial. Part-2]/
* httpx://en.wikipedia.org/wiki/Delimiter[Delimiter]
* httpx://en.wikipedia.org/wiki/Comma-separated_values[CSV]
* httpx://home.vrweb.de/~juergen.kahrs/gawk/XML/[XMLgawk]
* httpx://en.wikipedia.org/wiki/Awk[Awk]
* httpx://people.cs.uu.nl/piet/docs/nawk/nawk_23.html[Awk: Specifying how Fields are Separated]
* httpx://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.200x[LIBSTDC++ status +++C++11+++]
* httpx://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=286[Why I Hate Namespaces]

////////////////

BENCHMARKS
	A Benchmark for Reading Flat Files Into Memory for Awk, Python, Perl, Java, and Ruby (steve.80cols.com)
		http://www.reddit.com/r/programming/comments/pub98/a_benchmark_for_reading_flat_files_into_memory/
		v2 --  http://steve.80cols.com/flat_file_bakeoff.html
		v1 -- http://steve.80cols.com/reading_flat_files_into_memory_benchmark.html
		https://github.com/lorca/flat_file_benchmark/watchers
GNU AWK
	one liners -- http://www.gnu.org/s/gawk/manual/gawk.html#One_002dshot


TOKENIZER 
	http://www.codeproject.com/KB/recipes/Tokenizer.aspx
REGEX
	constexpr (at complie time) --
	http://cpptruths.blogspot.com/2011/07/compile-time-regex-matcher-using.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+CppTruths+%28C%2B%2B+Truths%29&utm_content=Google+Reader
	A Regular Expression Matcher by Rob Pike -- http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
	Writing own regular expression parser -- http://www.codeproject.com/KB/recipes/OwnRegExpressionsParser.aspx
	http://swtch.com/~rsc/regexp/
	PCRE++ http://www.linuxquestions.org/questions/showthread.php?p=4387972#post4387972
FORMATS
	JSON
		json parse in spirit -- http://boost-spirit.com/repository/applications/json_spirit.zip
		http://www.kirit.com/Blog:/2008-03-31/Thoughts%20on%20TinyJSON
		http://www.kirit.com/Thread:/1723074
		http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
		http://stackoverflow.com/a/8560856
		https://github.com/udp/json-parser

	CSV
		http://csvkit.readthedocs.org/en/latest/index.html
	XML
		xml parser in spirit
			-- http://boost-spirit.com/repository/applications/xml.zip
			-- http://boost-spirit.com/repository/applications/Arabica.html
		awk xml -- http://pastebin.com/Vwvz3gzb
		http://www.artima.com/cppsource/xml_data_binding.html
		http://www.grinninglizard.com/tinyxml/
		http://stackoverflow.com/questions/170686/best-open-xml-parser-for-c
		http://rapidxml.sourceforge.net/
		http://www.codeguru.com/cpp/data/data-misc/xml/article.php/c19341
		-----------
		There is a boost::xml in the sandbox and it's very good. We use
		TinyXML++ (which is decent) here but boost::xml was preferred; it was
		just too likely to change
	S-Expressions
		http://shinkirou.org/blog/2010/06/s-expressions-the-fat-free-alternative-to-json/
ENCODING
	Boost.Unicode: Aims at providing the foundation tools to
	accurately represent and deal with natural text in C++ in a
	portable and robust manner, so as to allow internationalized
	applications, by implementing parts of the Unicode Standard.
	(see (svn.boost.org/trac/boost/wiki/…;)
		
	This is already included as part of C++03. It's
	provided by the std::codecvt facet of the locale
	library
		
	Take a look on Boost.Locale it is a part of it
DB
	SQL parser in spriti -- http://boost-spirit.com/repository/applications/spirit_sql.zip
	SQL connectors -- http://www.reddit.com/r/cpp/comments/mrbc5/how_to_connect_to_an_sql_database/
	http://soci.sourceforge.net/
	https://svn.boost.org/trac/boost/wiki/LibrariesUnderConstruction#Boost.RDB
	http://webtoolkit.eu/wt#/blog/2009/11/26/wt__dbo__an_orm__c___style
	http://code.google.com/p/hiberlite/
	------------------
	Regarding boost::sql proposal, there is some work in progress:
	    * On BoostCon'09 Jeff Garland led workshop: Library in Week 2009 to discuss the std::rdb propsals, here are materials std::rdb (.tgz package)
	    * std_rdb - Boost sister mailing list to discuss standard rdb proposal(s)
	    * SOCI has been discussed in frame of the std::rdb mailing list and the workshop


////////////////////
