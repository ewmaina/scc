
include::/tmp/t.ad[]

In `scc` shall script:

* +++ C++ +++ snippet is decorated with usual boilerplate
* `simple.h`  and `scc.h` are included
* if `/usr/include/boost` is exsist then `boost/regex.hpp` is included
* If last (or only) statement (should be an expression) is not terminated by  `;` it is sent to `std::cout`.
* if stream options are used (-n or -p), then one line is read from `std::cin` per input cycle.
	Line split into fields and snippet is executed.
	If `-p` then  line is reassembled back from fields  and sent to `std::cout`
* Generated source compiled and executed.

In simple.h:

* Most of STL's includes are included with `using std::...` for most common objects. On my 4yr old laptop (no ssd), run time with cold cache - 2sec, with warm cache  <1sec.
* Code which allows most STL container to be printed to `std::cout` directly like `vector<int> V{1,2,3};   cout << V;`
* Code for simplified `std::cin` input
* Shortcut (macros and typedefs) making C++ verbosity more suitable for one-liner context

In scc.h defined:

* deque<str>	F
* read_line()

Predefined variables (similar to AWK's):

* line	-  `std::string`,  set if with `-n` / `-p` options  or after `read_line()`
* F	-  `std::deque<str>` line's fields; accessible like `F(i)`; counted from 0
* NF	-  `int`,  number of fields (set after read_line())
* NR 	-  `int`,  number of records (set after read_line())
* OFS 	-  `std::string`, output field separator 
* IFS 	-  `std::string`, input field separator.  
* CSV 	-  `const char[]`,  predefined regex for IFS

The `::str` type is derived from `std::string` and can be directly converted
to/from numeric types:

--------------------------------
str  s("1");
int  i;
i = s;		// string cast to int
i = s+1;	// 2
s = 1;		// "1"
s++		// "2"
s + " m/s"	// "2 m/s"
s + 5		// "7"
---------------------------------

Shortcuts
--------------------------------------
#define		WRL	while(read_line())

#define         R       regex
#define         RM      regex_match
#define         RS      regex_search
#define         CM      cmatch
#define         SM      smatch

#define		Vint	vector<int>
#define		Vuint	vector<unsigned int>
#define		Vfloat	vector<float>
#define		Vdouble	vector<double>
#define		Dint	deque<int>
#define		Duint	deque<unsigned int>
#define		Dfloat	deque<float>
#define		Ddouble	deque<double>
#define         S      string
#define         VS     vector<string>
#define         Vstr   vector<str>
#define         DS     deque<string>
#define         Dstr   deque<str>
--------------------------------------


== Install

-----------------------------------------
git clone http://github.com/lvv/scc
PATH+=":$PWD/scc" 
echo PATH+=":$PWD/scc" >> ~/.profile
---------------------------------------
///////////////////////////////////////////////
== status
capability		|  C++200?	|	>=GCC-4.4.4	|  >=GCC-4.4.4 && Boost

expression evaluation	|	Y	|	Y		| 	Y
stl container print	|	N 	|	Y		|	Y
c-array print		| 	N 	|	N		| 	Y
stream filter		| 	Y 	|	Y		| 	Y
regex			| 	N 	|	N		| 	Y
///////////////////////////////////////////////

== TODO

* Regex which parse out last statement (for sending it to std::cout) just looks for ';', so it won't work correctly for:

	- '{ code-block; } expr'
	- string literals with '"(){}'
	- snippets with space after last semicolon

  Simple workaround: use semicolon before last statement and do not put
  trailing spaces at the end of snippet

* All (now only part) of STL should included;
* All (now only part) of STL containers should be printable;
* Is it possible to make +++C++0x+++ literal for regex?  Ideally something
	like `/abc/` or `"abc"re` for `boost::regex("abc")`. 



== Refs 

* http://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/introduction_and_overview.html[Boost.Regex]
* http://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html[Perl Regular Expression Syntax]
* http://www.boost.org/doc/libs/1_46_1/libs/regex/doc/html/boost_regex/ref/regex_token_iterator.html[regex_token_iterator]
* http://www.boost.org/doc/libs/1_46_0/libs/format/doc/format.html#examples[Boost.Fromat]
